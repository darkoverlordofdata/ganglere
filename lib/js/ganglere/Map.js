// Generated by CoffeeScript 1.10.0
"use strict";
var ganglere,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ganglere = require('../ganglere');

ganglere.Map = (function() {
  var clone;

  Map.prototype.options = null;

  Map.prototype.tiles = null;

  Map.prototype.map = null;

  Map.prototype.rot = null;

  Map.prototype.height = 0;

  Map.prototype.width = 0;

  Map.prototype.imageheight = 0;

  Map.prototype.imagewidth = 0;

  Map.prototype.tileheight = 0;

  Map.prototype.tilewidth = 0;

  Map.prototype.tileset = '';

  Map.prototype.wall = 0;

  Map.prototype.space = 0;

  Map.prototype.artifacts = null;

  Map.prototype.data = null;

  clone = function(object) {
    return JSON.parse(JSON.stringify(object));
  };

  function Map(level) {
    this.level = level;
    this.addArtifacts = bind(this.addArtifacts, this);
    this.computeLight = bind(this.computeLight, this);
    this.resetLight = bind(this.resetLight, this);
    this.light = bind(this.light, this);
    this.isValidMove = bind(this.isValidMove, this);
    this.loadTilemap = bind(this.loadTilemap, this);
    this.options = this.level.options;
    this.map = this.level.add.tilemap(this.loadTilemap(this.options.map));
    this.map.addTilesetImage(this.tileset, this.tileset);
    this.map.createLayer('layer0', this.level.game.width, this.level.game.height - 40).resizeWorld();
    this.map.createLayer('layer1', this.level.game.width, this.level.game.height - 40).resizeWorld();
    this.tiles = JSON.parse(JSON.stringify(this.rot.map));
  }

  Map.prototype.loadTilemap = function(mapkey) {
    var json;
    json = this.getProperties(clone(this.level.cache.getJSON(mapkey + ".json")));
    this.rot = new ROT.Map.Rogue(this.width, this.height);
    this.rot.create((function(_this) {
      return function(x, y, v) {
        return json.layers[0].data[y * _this.width + x] = v === 1 ? _this.wall : _this.space;
      };
    })(this));
    if (this.options.artifacts) {
      this.addArtifacts(json, this.artifacts);
    }
    this.level.cache.addTilemap(mapkey, '', json);
    return mapkey;
  };

  Map.prototype.isValidMove = function(from, delta) {
    return from.x + delta.x >= 0 && from.x + delta.x < this.width && from.y + delta.y >= 0 && from.y + delta.y < this.height && this.tiles[from.x + delta.x][from.y + delta.y] === 0;
  };

  Map.prototype.light = function() {
    this.resetLight();
    this.fov = new ROT.FOV.PreciseShadowcasting((function(_this) {
      return function(x, y) {
        return typeof _this.tiles[x] === 'undefined' || typeof _this.tiles[x][y] === 'undefined' || _this.tiles[x][y] === 0;
      };
    })(this));
    return this.computeLight();
  };

  Map.prototype.resetLight = function() {
    var j, ref, results, tile, x, y;
    if (this.options.hide !== true) {
      return;
    }
    results = [];
    for (x = j = 0, ref = this.width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var k, ref1, results1;
        results1 = [];
        for (y = k = 0, ref1 = this.height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
          tile = this.map.getTile(x, y, 0);
          if (tile) {
            tile.alpha = 0;
          }
          tile = this.map.getTile(x, y, 1);
          if (tile) {
            results1.push(tile.alpha = 0);
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  Map.prototype.computeLight = function() {
    this.resetLight();
    this.level.actorList.forEach(function(a) {
      return a.sprite.alpha = 0;
    });
    this.level.actorList[0].sprite.alpha = 1;
    this.fov.compute(this.level.actorList[0].x, this.level.actorList[0].y, 10, (function(_this) {
      return function(x, y, r, visibility) {
        var tile;
        tile = _this.map.getTile(x, y, 0);
        if (tile) {
          tile.alpha = visibility;
        }
        tile = _this.map.getTile(x, y, 1);
        if (tile) {
          tile.alpha = visibility;
        }
        if (_this.level.actorMap.hasOwnProperty(x + '_' + y)) {
          return _this.level.actorMap[x + '_' + y].sprite.alpha = visibility;
        }
      };
    })(this));
    this.map.layers[0].dirty = true;
    return this.map.layers[1].dirty = true;
  };

  Map.prototype.getProperties = function(tilemap) {
    var key, ref, value;
    this.width = tilemap.width;
    this.height = tilemap.height;
    this.tileset = tilemap.tilesets[0].name;
    this.imageheight = tilemap.tilesets[0].imageheight;
    this.imagewidth = tilemap.tilesets[0].imagewidth;
    this.tileheight = tilemap.tileheight;
    this.tilewidth = tilemap.tilewidth;
    this.backgroundcolor = tilemap.backgroundcolor;
    if (tilemap.properties.wall != null) {
      this.wall = parseInt(tilemap.properties.wall, 10);
    } else {
      this.wall = 0;
    }
    if (tilemap.properties.space != null) {
      this.space = parseInt(tilemap.properties.space, 10);
    } else {
      this.space = (this.imageheight / this.tileheight) * (this.imagewidth / this.tilewidth);
    }
    if (tilemap.properties.artifacts != null) {
      this.artifacts = tilemap.properties.artifacts.split(',').map(function(v) {
        return parseInt(v, 10);
      });
    } else {
      this.artifacts = [];
    }
    this.data = {};
    ref = tilemap.properties;
    for (key in ref) {
      value = ref[key];
      if (/^m\d\d\$/.test(key)) {
        this.data[key.split('$')[1]] = value.split(',').map(function(v) {
          return parseInt(v, 10);
        });
      }
    }
    return tilemap;
  };

  Map.prototype.addArtifacts = function(tilemap, artifacts) {
    var data, direction, exist, fn, i, j, k, key, l, patternArray, ref, ref1, ref2, ref3, tilepos, x, y;
    exist = (function(_this) {
      return function(x, y) {
        if (typeof _this.rot.map[x] !== 'undefined' && typeof _this.rot.map[x][y] !== 'undefined' && _this.rot.map[x][y] === 0) {
          return '1';
        } else {
          return '0';
        }
      };
    })(this);
    patternArray = [];
    ref = this.data;
    fn = (function(_this) {
      return function(key, data) {
        return patternArray.push({
          pattern: new RegExp(key.replace(/\_/g, '[0-1]')),
          setTile: function(tilepos, x, y) {
            if (data[0] != null) {
              tilemap.layers[1].data[tilepos] = data[0];
              if ((data[1] != null) && y > 0) {
                return tilemap.layers[1].data[(y - 1) * _this.width + x] = data[1];
              }
            } else {
              return tilemap.layers[1].data[tilepos] = ganglere.Random.pick(artifacts);
            }
          }
        });
      };
    })(this);
    for (key in ref) {
      data = ref[key];
      fn(key, data);
    }
    for (y = j = 0, ref1 = this.height; 0 <= ref1 ? j < ref1 : j > ref1; y = 0 <= ref1 ? ++j : --j) {
      for (x = k = 0, ref2 = this.width; 0 <= ref2 ? k < ref2 : k > ref2; x = 0 <= ref2 ? ++k : --k) {
        if (this.rot.map[x][y] === 0) {
          continue;
        }
        tilepos = y * this.width + x;
        direction = exist(x - 1, y - 1) + exist(x, y - 1) + exist(x + 1, y - 1) + exist(x - 1, y) + '1' + exist(x + 1, y) + exist(x - 1, y + 1) + exist(x, y + 1) + exist(x + 1, y + 1);
        for (i = l = 0, ref3 = patternArray.length; 0 <= ref3 ? l < ref3 : l > ref3; i = 0 <= ref3 ? ++l : --l) {
          if (patternArray[i].pattern.test(direction)) {
            patternArray[i].setTile(tilepos, x, y);
            break;
          }
        }
      }
    }
    return tilemap;
  };

  return Map;

})();
